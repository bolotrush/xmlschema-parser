 <xs:element name="" type="" default/fixed="" />  - простой элемент
 <xs:attribute name="" type="" default/fixed="" use="required" />

 <element name = "">
 <simpleType>
 <restriction base="xs:integer">
 <minInclusive value="" />
 <maxInclusive value="" />
 </restriction>
 </simpleType>
 </element>

 Составные элементы: 1) пустые 2)содержат другие элементы (как я понимаю, массив структур, например)
 3) содержат текст 4) 2)+3)

 <xs:element name="" type="personInfo"/>
 <xs:complexType name="personInfo">
 <xs:sequence> ---> декларированные поля должны быть в этом порядке!
 <xs:element name="firstname" type=""/>
 <xs:element name="secondname" type=""/>
 </xs:sequence>
 </xs:complexType>

 Тип может быть расширяем. Пусть есть <complexType name="personInfo">. Мы его используем, а для другого поля нужно тоже
 самое + еще пару полей
 Значит пишем новый <complexType>, где указываем доп поля + пишем: <extension base="personInfo">

 <xs:simpleContent> - текст и атрибуты. Добавляем тег после <complexType>, но до <extension/restriction>

 restrictions:
 enumeration - список приемлемых значений
 fractionDigits - максимальное число знаков после десятичной запятой
 length
 maxExclusive - верхняя граница для числовых значений (меньше указанного)
 maxInclusive - то же самое, но меньше или равно указанному
 maxLength
 minExclusive
 minInclusive
 minLength
 pattern - Точная последовательность приемлемых символов (регулярки для ограничения значения)
 totalDigits - точное количество допустимых цифр
 whiteSpace - способ обработки пробелов

 Индикаторы очередности:
 <xs:all> - ве дочерние в любом порядке только 1 раз
 <xs:choice> - какой-то один дочерний элемент. Либо то, либо другое
 <xs:sequence>

 Индикаторы частности - пишется В теге элемента:
 maxOccurs = "" - максимальное число появления элемента "unbounded"
 minOccurs = ""

 Индикаторы группирования:
 <xs:group name="">
 Внутри необходимо указать индикатор очередности и далее перечисояем элементы
 Потом в <complexType> обращаемся <xs:group ref="Имя группы">

 <xs:attributeGroup> - аналогично, но не надо указывать очередность

 Тег <xs:any/> - как "любой элемент" для расширения
 <xs:anyAttribute/>

 Замещение!
 <element name="name" type=""/>
 <element name="" substitutionGroup="name"/>
 Защита от замещения атрибут block в элементе